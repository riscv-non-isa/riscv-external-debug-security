[[Sdsec]]
== Sdsec (ISA extension)

This chapter introduces the Sdsec ISA extension, which adds security enhancements to the Sdext/Sdtrig cite:[dbgspec] and trace functionality cite:[etrace] cite:[ntrace]. The extension provides mandatory M-mode external debug and trace control, along with optional extensions for lower privilege modes.

It defines the following debug and trace control extensions:

* **M-mode Control (Smmdedbg)**: Mandatory control for M-mode external debug and trace
* **S-mode Control (Smsdedbg)**: Optional extension for S/HS-mode external debug and trace
* **VS-mode Control (Smvsdedbg)**: Optional extension for VS-mode external debug and trace  
* **U-mode Control (Smudedbg)**: Optional extension for U/VU-mode external debug and trace

When external debug or trace is allowed for a privilege mode, it is allowed for all lower privilege modes as well. External debug and trace controls operate independently - a privilege mode can have external debug enabled while trace is disabled, or vice versa.

The following table summarizes the external debug and trace control signals/fields and associated CSRs:

[[dbgctlcsr]]
.External Debug and Trace Control and CSRs
[cols="15%,30%,30%,15%,25%", options="header"]
|=====================================================================
| Extension          | External Debug Control    |  Trace Control    | New CSRs      | Target Modes
| Smmdedbg           | mdbgen            | mtrcen           | None          | M-mode
| Smsdedbg           | msdcfg.SDEDBGALW | msdcfg.SDETRCALW | sdcsr, sdpc   | S/HS-mode  
| Smvsdedbg          | msdcfg.VSEDBGALW | msdcfg.VSETRCALW | None          | VS-mode
| Smudedbg           | msdcfg.USEDBGALW | msdcfg.USETRCALW | udcsr, udpc   | U-Mode or VU-mode
|=====================================================================

[NOTE]
Users can choose to implement some or all of the optional extensions depending on their system requirements. These extensions work together to establish a hierarchical external debug and trace control model where external debug access or trace output can be restricted to specific privilege levels, preventing unauthorized debugging or tracing. 

The following table shows valid implementation combinations for different architectures:

[[validimplcomb]]
.Valid Implementation Combinations
[cols="25%,75%", options="header"]
|=====================================================================
| Architecture    | Valid Extension Combinations           
| M-only          | • Smmdedbg only                    
| M/U             | • Smmdedbg only +
                    • Smmdedbg + Smudedbg         
| M/S/U           | • Smmdedbg only +
                    • Smmdedbg + Smsdedbg +
                    • Smmdedbg + Smsdedbg + Smudedbg                     
| M/S/VS/VU/U     | • Smmdedbg only +
                    • Smmdedbg + Smsdedbg +
                    • Smmdedbg + Smsdedbg + Smvsdedbg +
                    • Smmdedbg + Smsdedbg + Smvsdedbg + Smudedbg                 
|=====================================================================

[[Sdseccsr]]
=== Debug Control CSR

The CSR `msdcfg`, which holds the external debug and trace control fields (<<dbgctlcsr>>), is defined in the RISC-V Supervisor Domains Access Protection specification cite:[smmtt]. The Smsdedbg and/or Smsdetrc extensions must be implemented to support security control for external debugging and/or tracing in the corresponding privilege modes.


[[sdsecextdbg]]
=== External Debug and Trace

Chapter 3 of _The RISC-V Debug Specification_ cite:[dbgspec] outlines all mandatory and optional external debug operations. The operations listed below are affected by the Sdsec extension; other operations remain unaffected. In the context of this chapter, *debug operations* refer to those listed below.

Debug operations affected by Sdsec: 
[[dbops]]
* Halting the hart to enter Debug Mode
* Executing the Program Buffer
* Serving abstract commands (Access Register, Access Memory)

[[dbgaccpriv]]
==== Debug Access Privilege

The *debug access privilege* is defined as the privilege level for state accesses in Debug Mode, such as Abstract Commands and Program Buffer execution. When Sdsec is implemented, Debug Mode accessing registers and memory uses the privilege level derived in <<dbgpriv>>. Attempts from Debug Mode to access state that requires a privilege level above the *debug access privilege* will fail and set `abstractcs`.CMDERR to 3. 

[[dbgpriv]]
[options="header"]
[cols="15%,20%,20%,20%,25%"]
.External Debug Configuration and Privilege
|=====================================================================================================
| mdbgen | SDEDBGALW  | VSEDBGALW  | UEDBGALW   | Debug Access Privilege
| 1      | Don't care | Don't care | Don't care | M-mode                
| 0      | 1          | Don't care | Don't care  | S/HS-Mode             
| 0      | 0          | 1          | Don't care | VS-Mode               
| 0      | 0          | 0          | 1          | U-Mode or VU-Mode             
| 0      | 0          | 0          | 0          | None                  
|=====================================================================================================

==== Maximum Allowed Resume Privilege Mode

With Sdsec implemented, the maximum privilege level that can be configured in `dcsr`.PRV and `dcsr`.V is determined in <<maxdbgpriv>>. The fields retain legal values when the `dcsr`.PRV and `dcsr`.V are configured with an illegal privilege level. Illegal privilege levels include unsupported levels and any level higher than the maximum allowed debug privilege. 

[[maxdbgpriv]]
[options="header"]
[cols="15%,20%,20%,20%,25%"]
.Maximum Allowed Resume Privilege Mode
|=====================================================================================================
| mdbgen | SDEDBGALW  | VSEDBGALW  | UEDBGALW   | Maximum Debug Allowed Privilege on resume 
| 1      | Don't care | Don't care | Don't care | M-Mode                                         
| 0      | 1          | Don't care | Don't care | S/HS-Mode                                  
| 0      | 0          | 1          | Don't care | VS-Mode
| 0      | 0          | 0          | 1          | U-Mode or VU-Mode
| 0      | 0          | 0          | 0          | None
|=====================================================================================================

==== Privilege-changing Instructions

Privilege-changing instructions (other than EBREAK) executed in the Program Buffer must either act as a NOP or raise an exception (stopping execution and setting `abstractcs`.CMDERR to 3). 

[[mdbgctl]]
==== M-mode External Debug and Trace Control (Smmdedbg)

The Smmdedbg extension introduces mandatory security controls for M-mode external debug and trace operations. Two state elements are defined in each hart:

* `mdbgen`: Controls M-mode external debug operations
* `mtrcen`: Controls M-mode trace output

[NOTE]
The `mdbgen` and `mtrcen` may be controlled through various methods, such as a new input port to the hart, a handshake with the system Root of Trust (RoT), or other methods. The `mdbgen` and `mtrcen` state for the Root-of-Trust (RoT) itself should be managed by SoC hardware, likely dependent on lifecycle fusing. 
The implementation can choose to group several harts together and use one signal to drive their `mdbgen` and `mtrcen` state or assign each hart its own dedicated state. For example, a homogeneous computing system can use a signal to drive all `mdbgen` and `mtrcen` states to enforce a unified debug policy across all harts.

===== M-mode External Debug Control

A state element in each hart, named `mdbgen`, is introduced to control the debuggability of M-mode for each hart as depicted in <<extdbg>>. When `mdbgen` is set to 1, debug is allowed for M-mode and the following rules apply:

- The <<dbgaccpriv, debug access privilege>> for the hart is M-mode. Abstract Commands, including "Quick Access", and Program Buffer execution operate with M-mode privilege.
- The <<dbops, debug operations>> are allowed when the hart executes in any privilege mode.

When `mdbgen` is set to 0 and the hart is running in M-mode, external debug is disallowed for M-mode:

- The hart will not enter Debug Mode:
  * Halt requests will remain pending until external debug is allowed.  
  * Triggers with ACTION=1 (enter Debug Mode) will not match or fire.
  * EBREAK cannot enter Debug Mode and always raises a breakpoint exception.
- The external trigger outputs (with ACTION=8/9) will not match or fire.

If the hart is running in a debug-allowed privilege mode when `mdbgen` is 0: 

- Single-stepping cannot stop in M-mode.
- Interrupts to M-mode cannot be disabled by setting `dcsr`.STEPIE=0. 

[NOTE]
When `mdbgen`=0 and `dcsr`.STEP=1, a single-stepped instruction in a debug-allowed privilege mode may transfer control to the M-mode trap handler. The hart will execute the handler in M-mode and re-enter Debug Mode immediately after an MRET instruction returns to the debug-allowed privilege mode (i.e., MRET with `mstatus`.MPP<3). The hart does not re-enter Debug Mode if the MRET instruction returns to a debug-disallowed privilege mode (i.e., MRET with `mstatus`.MPP=3, `mdbgen`=0). 

[NOTE]
This specification assumes the controlling entity ensures `mdbgen` shall never be set to 0 while the hart is in Debug Mode. Setting `mdbgen` to 0 while in Debug Mode could lead to undefined behavior; the hart may lose its debug privileges unexpectedly, potentially causing the debug session to fail or become insecure.

===== M-mode Trace Control

A state element in each hart, named `mtrcen`, is introduced to control trace output for M-mode. When `mtrcen` is set to 1, trace is allowed for all privilege modes. When `mtrcen` is set to 0, trace is inhibited for M-mode by asserting the logical `sec_inhibit` signal to the trace encoder when the hart is executing in M-mode.

[NOTE]
The availability of trace output is controlled through signals defined in the hart-trace interface (HTI) cite:[hti]. The logical `sec_inhibit` signal can be converted to the canonical trace interface signals by implementation.

===== CSR update in Smmdedbg
The `dcsr`, `dpc`, and `dscratch0/1` are accessible in Debug Mode only if `mdbgen`=1; otherwise, the access will fail and `abstractcs`.CMDERR is set to 3 (exception). When external debug is disallowed in M-mode, the configuration in `dcsr` will be ignored as if it were 0 while the hart runs in M-mode.

===== DMODE in `tdata1`

When the Sdsec extension is implemented, DMODE is read/write for both M-mode and Debug Mode when `mdbgen` is 0, and remains only accessible to Debug Mode when `mdbgen` is 1.

[NOTE]
M-mode is given write access to DMODE to allow it to save/restore trigger context on behalf of a supervisor debugger. Otherwise, a trigger could serve as a side-channel to debug-disallowed supervisor domains. The trigger may raise a breakpoint exception in a supervisor domain where debugging is disallowed. This could allow the external debugger to indirectly observe the state from the debug-disallowed supervisor domain (PC, data address, etc.) and may even result in a Denial of Service (DoS). By making DMODE M-mode accessible when `mdbgen` is 0, such an attack can be mitigated by having M-mode firmware switch the trigger context at the supervisor domain boundary.

[[smsdbgctl]]
==== S/HS-mode External Debug and Trace Control (Smsdedbg)

The optional Smsdedbg extension introduces the following fields in CSR <<Sdseccsr,`msdcfg`>>:

* `SDEDBGALW` (bit 7): Controls S/HS-mode external debug operations
* `SDETRCALW` (bit 8): Controls S/HS-mode trace output

These fields only take effect when `mdbgen` and `mtrcen` are 0 respectively; otherwise, debug and trace control is dominated by M-mode settings.

[NOTE]
All behavior described in this section applies only when `mdbgen` is 0 for external debug control and `mtrcen` is 0 for trace control.

===== S/HS-mode External Debug Control

The `SDEDBGALW` field controls external debug access for S/HS-mode. When `SDEDBGALW` is set to 1, S/HS-mode external debug is allowed:

- The <<dbgaccpriv, debug access privilege>> for the hart is S/HS-mode. Abstract Commands, including "Quick Access", and Program Buffer execution operate with S/HS-mode privilege.
- The <<dbops, debug operations>> are allowed when the hart executes in S/HS-mode.

When `SDEDBGALW` is set to 0 and the hart is running in S/HS-mode, external debug is disallowed for S/HS-mode:

- The hart will not enter Debug Mode while running in S/HS-mode:
  * Halt requests will remain pending until external debug is allowed.  
  * Triggers with ACTION=1 (enter Debug Mode) will not match or fire.
  * EBREAK cannot enter Debug Mode and always raises a breakpoint exception.
- The external trigger outputs (with ACTION=8/9) will not match or fire while in S/HS-mode.

When `SDEDBGALW` is set to 0 and the hart is running in a debug-allowed lower privilege mode, S/HS-mode restrictions include:

- Single-stepping cannot stop in S/HS-mode.
- Interrupts delegated to S/HS-mode cannot be disabled by setting `dcsr`.STEPIE=0. 

[NOTE]
When `SDEDBGALW`=0 and `sdcsr`.STEP=1, a single-stepped instruction in a debug-allowed privilege mode may transfer control to the S/HS-mode trap handler. The hart will execute the handler in S/HS-mode and re-enter Debug Mode immediately after an SRET instruction returns to the debug-allowed privilege mode (i.e., SRET with `sstatus`.SPP=0). The hart does not re-enter Debug Mode if the SRET instruction returns to a debug-disallowed privilege mode.

===== S/HS-mode Trace Control

The `SDETRCALW` field controls trace output for S/HS-mode. When `SDETRCALW` is set to 1, trace is allowed for all privilege modes except M-mode. When `SDETRCALW` is set to 0, trace is inhibited for S/HS-mode by asserting the logical `sec_inhibit` signal to the trace encoder when the hart is executing in S/HS-mode. 

===== CSR update in Smsdedbg

The `sdcsr` and `sdpc` <<smodecsr>> are introduced in Smsdedbg. They are accessible in Debug Mode if `SDEDBGALW`=1. When external debug is disallowed in S/HS-mode, the configuration visible in `sdcsr` will be ignored as if it were 0 while the hart runs in S/HS-mode.

[[smodecsr]]
====== `Sdcsr` and `sdpc`

When `SDEDBGALW` is 1, the `sdcsr` and `sdpc` registers provide S/HS-mode read/write access to the `dcsr` and `dpc` registers respectively. However, `sdcsr` does not expose access to the `MPRVEN` field; instead, it repurposes the `MPRVEN` bit position with a `DMPRV` field to modify the *effective debug access privilege* in S/HS-mode. Both registers are only accessible in Debug Mode.

.Allocated addresses for S/HS-mode shadow of Debug Mode CSR  
[options="header"]
[cols="25%,25%,50%"]
|============================================================================================
| Number   | Name       | Description
| 0xaaa    | sdcsr      | S/HS-mode debug control and status register.
| 0xaaa    | sdpc       | S/HS-mode debug program counter. 
|============================================================================================

The `sdcsr` register exposes a subset of `dcsr`, formatted as shown in <<sdcsr32>>, while the `sdpc` register provides full access to `dpc`.

[NOTE]
Unlike `dcsr` and `dpc`, the `dscratch0/1` registers do not have a S/HS-mode access mechanism, and external debuggers with S/HS-mode privilege cannot use them.

[caption="Register {counter:rimage}: ", reftext="Register {rimage}"]
[title="S/HS-mode debug control and status register (sdcsr)"]
[id=sdcsr32]
[wavedrom, ,svg]
....
{reg: [
  {bits:   1, name: 'PRV'},
  {bits:   1, name: '0'},
  {bits:   1, name: 'STEP'},
  {bits:   1, name: '0'},
  {bits:   1, name: 'DMPRV'},
  {bits:   1, name: 'V'},
  {bits:   3, name: 'CAUSE'},
  {bits:   2, name: '0'},
  {bits:   1, name: 'STEPIE'},
  {bits:   1, name: 'EBREAKU'},
  {bits:   1, name: 'EBREAKS'},
  {bits:   2, name: '0'},
  {bits:   1, name: 'EBREAKVU'},
  {bits:   1, name: 'EBREAKVS'},
  {bits:   6, name: '0'},
  {bits:   3, name: 'EXTCAUSE'},
  {bits:   1, name: '0'},
  {bits:   4, name: 'DEBUGVER'}
], config:{lanes: 3, hspace:1024}}
....

[NOTE]
The NMIP, MPRVEN, STOPTIME, STOPCOUNT, EBREAKM, and CETRIG fields in `dcsr` are configurable only by M-mode; they are masked in `sdcsr`, while PRV[1] is hardwired to 0 in `sdcsr`. The field for MPRVEN is reclaimed by DMPRV in `sdcsr` layout to avoid waste of fields. 

[[dmprv]]
.Details of the `dmprv` field in `sdcsr`
[options="header"]
[cols="15%,55%,15%,15%"]
|=================================================================================================================================================================
| Field | Description                                                                                                                          | Access | Reset  
| DMPRV | 0 (normal): The privilege level in Debug Mode is not modified.

1: In Debug Mode, the privilege level for load and store operations is modified to the effective debug access privilege as described in <<effectivedbgpriv>> and <<vseffectivedbgpriv>>.| WARL   | 0      
|=================================================================================================================================================================

====== Extension of Sdtrig CSR

The Smtdeleg/Sstcfg cite:[smtdeleg] extensions define the process for delegating triggers to modes with lower privilege than M-mode. If Sdtrig is supported, the Sdsec requires both extensions to securely delegate Sdtrig triggers to the S/HS-mode.

[NOTE]
When M-mode enables debugging for the S/HS-mode, it can optionally delegate the triggers to the S/HS-mode, allowing an external debugger with S/HS-mode privilege to configure these triggers.

[[effectivedbgpriv]]
===== Debug Access Privilege to memory in Smsdedbg

The `sdcsr`.DMPRV takes effect when `mdbgen` is 0, and it is read-only 0 when `mdbgen` is 1. With `SDEDBGALW` set to 1, the *effective debug access privilege* of loads and stores by an S/HS-mode debugger to access memory in Debug Mode can be modified by `sdcsr`.DMPRV. When `sdcsr`.DMPRV=0, the *effective debug access privilege* of loads and stores in Debug Mode follows <<dbgpriv>>; when `sdcsr`.DMPRV=1, the *effective debug access privilege* of loads and stores in Debug Mode is represented by:

- `sstatus`.SPP or,
- `hstatus`.SPVP and `hstatus`.SPV if the hypervisor extension is supported.

The `sdcsr`.DMPRV does not affect the virtual-machine load/store instructions, HLV, HLVX, and HSV. 

==== VS-mode External Debug and Trace Control (Smvsdedbg)

The optional Smvsdedbg extension introduces the following fields in CSR <<Sdseccsr,`msdcfg`>>:

* `VSEDBGALW` (bit TBD): Controls VS-mode external debug operations
* `VSETRCALW` (bit TBD): Controls VS-mode trace output

These fields only take effect when both `mdbgen`/`SDEDBGALW` and `mtrcen`/`SDETRCALW` are 0 respectively; otherwise, control is dominated by M-mode or S/HS-mode settings.

[NOTE]
All behavior described in this section applies only when both `mdbgen` and `SDEDBGALW` are 0 for external debug control, and both `mtrcen` and `SDETRCALW` are 0 for trace control. 

===== VS-mode External Debug Control

The `VSEDBGALW` field controls external debug access for VS-mode. When `VSEDBGALW` is set to 1, VS-mode external debug is allowed:

- The <<dbgaccpriv, debug access privilege>> for the hart is VS-mode. Abstract Commands, including "Quick Access", and Program Buffer execution operate with VS-mode privilege.
- The <<dbops, debug operations>> are allowed when the hart executes in VS-mode.

When `VSEDBGALW` is set to 0 and the hart is running in VS-mode, external debug is disallowed for VS-mode:

- The hart will not enter Debug Mode while running in VS-mode:
  * Halt requests will remain pending until external debug is allowed.  
  * Triggers with ACTION=1 (enter Debug Mode) will not match or fire.
  * EBREAK cannot enter Debug Mode and always raises a breakpoint exception.
- The external trigger outputs (with ACTION=8/9) will not match or fire while in VS-mode.

When `VSEDBGALW` is set to 0 and the hart is running in a debug-allowed lower privilege mode, VS-mode restrictions include:

- Single-stepping cannot stop in VS-mode.
- Interrupts delegated to VS-mode cannot be disabled by setting `sdcsr`.STEPIE=0. 

[NOTE]
When `VSEDBGALW`=0 and `sdcsr`.STEP=1, a single-stepped instruction in a debug-allowed privilege mode may transfer control to the VS-mode trap handler. The hart will execute the handler in VS-mode and re-enter Debug Mode immediately after an SRET instruction returns to the debug-allowed privilege mode (i.e., SRET with `vsstatus`.SPP=0). The hart does not re-enter Debug Mode if the SRET instruction returns to a debug-disallowed privilege mode (i.e., SRET with `vsstatus`.SPP=1, `VSEDBGALW`=0).

===== VS-mode Trace Control

The `VSETRCALW` field controls trace output for VS-mode. When `VSETRCALW` is set to 1, trace is allowed for VS-mode and VU-mode. When `VSETRCALW` is set to 0, trace is inhibited for VS-mode by asserting the logical `sec_inhibit` signal to the trace encoder when the hart is executing in VS-mode. 

===== CSR update in Smvsdedbg

When `VSEDBGALW` is 1, the `sdcsr` and `sdpc` <<smodecsr>> are accessible with virtual supervisor privilege, providing access to the `dcsr`. The `sdcsr`.EBREAKS and `sdcsr`.EBREAKU fields are redirected to `dcsr`.EBREAKVS and `dcsr`.EBREAKVU, while writes to `sdcsr`.EBREAKVS, `sdcsr`.EBREAKVU, and `sdcsr`.V are discarded (reads return 0). Similar to `sdcsr` access when `SDEDBGALW` is 1, `sdcsr`.DMPRV modifies the *effective debug access privilege* in VS-mode. When external debug is disallowed in VS-mode, the configuration visible in `sdcsr` will be ignored as if it were 0 while the hart runs in VS-mode.

[NOTE]
Redirected access to `dcsr`.EBREAKVS and `dcsr`.EBREAKVU unifies the configuration for both S/HS-mode and VS-mode. The virtualization mode cannot be changed through `sdcsr`.V by a VS-mode debugger.

[[vseffectivedbgpriv]]
===== Debug Access Privilege to memory in Smvsdedbg

The `sdcsr`.DMPRV modifies the *effective debug access privilege* of loads and stores for a VS-mode debugger when `SDEDBGALW` is 0 and `VSEDBGALW` is 1.

When `sdcsr`.DMPRV=0, the *effective debug access privilege* of loads and stores in Debug Mode follows <<dbgpriv>>; when `sdcsr`.DMPRV=1, the *effective debug access privilege* of loads and stores in Debug Mode is represented by `vsstatus`.SPP with the virtualization mode being honored as 1.

==== U-mode External Debug and Trace Control (Smudedbg)

The optional Smudedbg extension introduces the following fields in CSR <<Sdseccsr,`msdcfg`>>:

* `USEDBGALW` (bit TBD): Controls U/VU-mode external debug operations
* `USETRCALW` (bit TBD): Controls U/VU-mode trace output

These fields only take effect when all higher privilege mode controls are 0; otherwise, control is dominated by higher privilege mode settings.

[NOTE]
All behavior described in this section applies only when `mdbgen`, `SDEDBGALW`, and `VSEDBGALW` are 0 for external debug control, and `mtrcen`, `SDETRCALW`, and `VSETRCALW` are 0 for trace control.

===== U-mode External Debug Control

The `USEDBGALW` field only takes effect when `mdbgen` and `SDEDBGALW` are 0 if virtualization mode is 0, or `mdbgen`, `SDEDBGALW`, and `VSEDBGALW` are 0 if virtualization mode is 1; otherwise, debug control is dominated by `mdbgen`, `SDEDBGALW`, or `VSEDBGALW` as if `USEDBGALW` is 0.

When `USEDBGALW` is set to 1, U-mode or VU-mode (when virtualization mode is 1) external debug is allowed:

- The <<dbgaccpriv, debug access privilege>> for the hart is U-mode or VU-mode. Abstract Commands, including "Quick Access", and Program Buffer execution operate with U-mode or VU-mode privilege.
- The <<dbops, debug operations>> are allowed when the hart executes in U-mode or VU-mode.

When `USEDBGALW` is set to 0 and the hart is running in U-mode (or VU-mode when virtualization mode is 1), external debug is disallowed for all modes: 

- The hart will not enter Debug Mode 
  * Halt requests will remain pending until external debug is allowed.  
  * Triggers with ACTION=1 (enter Debug Mode) will not match or fire.
  * EBREAK cannot enter Debug Mode and always raises a breakpoint exception.
- The external trigger outputs (with ACTION=8/9) will not match or fire

===== U-mode Trace Control

The `USETRCALW` field controls trace output for U-mode or VU-mode. When `USETRCALW` is set to 1, trace is allowed for U-mode or VU-mode. When `USETRCALW` is set to 0, trace is inhibited for all privilege modes by asserting the logical `sec_inhibit` signal to the trace encoder. 

===== CSR update in Smudedbg

The `udcsr` and `udpc` <<umodecsr>> are introduced in Smudedbg. They are accessible in Debug Mode if `USEDBGALW`=1. When external debug is disallowed in U-mode or VU-mode (`USEDBGALW`=0), the configuration visible in `udcsr` will be ignored as if it were 0.

[[umodecsr]]
====== `Udcsr` and `udpc`

The `udcsr` and `udpc` registers provide U-mode or VU-mode read/write access to the `dcsr` and `dpc` registers respectively. The `udcsr` exposes a subset of `dcsr` and the accessible fields are listed in <<udcsr32>>. The read/write access to the `udcsr`.EBREAKU field is redirected to `dcsr`.EBREAKVU when the virtualization mode is 1. The `udpc` register provides full access to `dpc`.

[NOTE]
Redirected access to `dcsr`.EBREAKVU unifies the configuration for both U-mode and VU-mode. 

.Allocated addresses for U-mode shadow of Debug Mode CSR  
[options="header"]
[cols="25%,25%,50%"]
|============================================================================================
| Number   | Name       | Description
| 0xaaa    | udcsr      | U-mode debug control and status register.
| 0xaaa    | udpc       | U-mode debug program counter. 
|============================================================================================

The `udcsr` register exposes a subset of `dcsr`, formatted as shown in <<udcsr32>>, while the `udpc` register provides full access to `dpc`.

[caption="Register {counter:rimage}: ", reftext="Register {rimage}"]
[title="U-mode debug control and status register (udcsr)"]
[id=udcsr32]
[wavedrom, ,svg]
....
{reg: [
  {bits:   2, name: '0'},
  {bits:   1, name: 'STEP'},
  {bits:   3, name: '0'},
  {bits:   1, name: 'V'},
  {bits:   3, name: 'CAUSE'},
  {bits:   2, name: '0'},
  {bits:   1, name: 'STEPIE'},
  {bits:   11,name: '0'},
  {bits:   3, name: 'EXTCAUSE'},
  {bits:   1, name: '0'},
  {bits:   4, name: 'DEBUGVER'}
], config:{lanes: 2, hspace:1024}}
....

//[[tracepriv]]
//[options="header"]
//[cols="5*"]
//.Trace Security Control
//|=====================================================================================================
//| mtrcen | SDETRCALW  | VSETRCALW  | USETRCALW  | Trace Allowed Mode
//| 1      | Don't care | Don't care | Don't care | All modes                
//| 0      | 1          | Don't care | Don't care | All except M-mode             
//| 0      | 0          | 1          | Don't care | VS-Mode and VU-Mode               
//| 0      | 0          | 0          | 1          | U-Mode or VU-Mode             
//| 0      | 0          | 0          | 0          | None                  
//|=====================================================================================================
