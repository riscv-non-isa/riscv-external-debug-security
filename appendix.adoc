[appendix]
== Theory of Operation 

This chapter explains the theory of operation for the External Debug Security Extension. The subsequent diagrams illustrate the reference implementation of security control for external debug and trace, respectively.

=== External Debug Security Control

The dedicated debug security policy for a hart is enforced through a hierarchical control model using M-mode control state `mdbgen` and optional lower privilege mode control fields (`SDEDBGALW`, `VSEDBGALW`, `USEDBGALW`) in the `msdcfg` CSR. The `mdbgen` state can be implemented as an input signal to the hart, managed through platform-specific mechanisms such as Debug Module registers, Root of Trust (RoT) handshake, or lifecycle fuses, etc. Moreover, the platform state `nsecdbg` can be used to override the debug security policy in platform level and provide unrestricted debug access for all privilege modes.

The security control logic validates all debug requests and triggers (with ACTION=1) against the current privilege level of the hart and the configured debug security policy. The validation procedure involves two steps: 1) checking the platform state `nsecdbg` to determine if unrestricted debug access is allowed; 2) checking the hierarchical controls to determine if external debug is allowed at the hart's current privilege level. Debug requests that fail validation will either be dropped or kept pending until the hart transitions to a debug-allowed privilege mode.

[[extdbg]]
image::external_debug_dm.png[title="The debug security control",align="center"]

The hierarchical control applies as follows:
- When `mdbgen`=1, external debug is allowed for all privilege modes 
- When `mdbgen`=0 and `SDEDBGALW`=1 (if implemented), external debug is allowed for S/HS-mode and lower privilege modes 
- When `mdbgen`=0, `SDEDBGALW`=0, and `VSEDBGALW`=1 (if implemented), external debug is allowed for VS-mode and VU-mode 
- When all higher privilege controls are 0 and `USEDBGALW`=1 (if implemented), external debug is allowed for U-mode or VU-mode only 
- When all control fields are 0, external debug is completely disallowed

The tables below show valid implementation combinations for different architectures for external debug:

[[validimplcomb]]
.Valid External Debug Extension Combinations
[cols="25%,75%", options="header"]
|=====================================================================
| Architecture    | Valid Debug Extension Combinations           
| M-only          | • Smmdedbg 
| M/U             | • Smmdedbg +
                    • Smmdedbg + Smudedbg         
| M/S/U           | • Smmdedbg +
                    • Smmdedbg + Smsdedbg +
                    • Smmdedbg + Smsdedbg + Smudedbg                     
| M/S/VS/VU/U     | • Smmdedbg +
                    • Smmdedbg + Smsdedbg +
                    • Smmdedbg + Smsdedbg + Smvsdedbg +
                    • Smmdedbg + Smsdedbg + Smvsdedbg + Smudedbg                 
|=====================================================================

The validation process must ensure that both the validation and execution of debug requests occur under the same privilege level and the same debug security policy to prevent Time-of-Check Time-of-Use (TOCTOU) vulnerabilities. Failing to do so may allow debug requests to bypass security controls. 


[NOTE]
The self-hosted debugging is also commonly used in application-level debugging, providing a pure software-based debugging solution without the need for external debugger. It is orthogonal to the external debugging and will not be affected by the debug security controls.


=== Trace Security Control 

The trace security policy for a hart is enforced through a hierarchical control model using M-mode control state `mtrcen` and optional lower privilege mode control fields (`SDETRCALW`, `VSETRCALW`, `USETRCALW`) in the `msdcfg` CSR. The `mtrcen` state can be implemented as an input signal to the hart, managed through platform-specific mechanisms such as Root of Trust (RoT) handshake or lifecycle fuses, etc. 

The security control logic asserts the `sec_inhibit` sideband signal to the trace encoder based on the current privilege level of the hart and the configured trace security policy. The validation procedure checks the hierarchical controls to determine if trace is allowed at the hart's current privilege level. Trace will be inhibited by asserting the `sec_inhibit` signal if the validation fails. 

[[exttrace]]
image::external_debug_trace.png[title="The trace security control",align="center"]

The hierarchical control applies as follows:
- When `mtrcen`=1, trace is allowed for all privilege modes
- When `mtrcen`=0 and `SDETRCALW`=1 (if implemented), trace is allowed for S/HS-mode and lower privilege modes; trace is inhibited for M-mode
- When `mtrcen`=0, `SDETRCALW`=0, and `VSETRCALW`=1 (if implemented), trace is allowed for VS-mode and VU-mode; trace is inhibited for M-mode and S/HS-mode
- When all higher privilege controls are 0 and `USETRCALW`=1 (if implemented), trace is allowed for U-mode or VU-mode only; trace is inhibited for all higher privilege modes
- When all control fields are 0, trace is completely inhibited for all privilege modes

The tables below show valid implementation combinations for different architectures for trace:

[[validtrccomb]]
.Valid Trace Extension Combinations
[cols="25%,75%", options="header"]
|=====================================================================
| Architecture    | Valid Trace Extension Combinations           
| M-only          | • Smmdetrc 
| M/U             | • Smmdetrc +
                    • Smmdetrc + Smudetrc         
| M/S/U           | • Smmdetrc +
                    • Smmdetrc + Smsdetrc +
                    • Smmdetrc + Smsdetrc + Smudetrc                     
| M/S/VS/VU/U     | • Smmdetrc +
                    • Smmdetrc + Smsdetrc +
                    • Smmdetrc + Smsdetrc + Smvsdetrc +
                    • Smmdetrc + Smsdetrc + Smvsdetrc + Smudetrc                 
|=====================================================================

[appendix]
== Software Debug Policy Management 

This section provides guidance on how software at different privilege levels can manage debug policies.

=== M-mode Management 

M-mode software is responsible for managing the `SDEDBGALW`, `VSEDBGALW`, and `USEDBGALW` fields in the `msdcfg` CSR. The `mdbgen` state is typically controlled by platform hardware (RoT, lifecycle fuses) and is read-only from software perspective.

M-mode software should:

1. Initialize debug policy for lower privilege modes based on security requirements
2. Provide interfaces for dynamic debug policy updates (e.g., through SBI calls from lower privilege modes)
3. Context-switch debug policies when switching between supervisor softwares 
4. Save and restore trigger context (using DMODE access when `mdbgen`=0) during supervisor software switches to prevent side-channel attacks

=== S/HS-mode Management

S/HS-mode software is responsible for managing debug policy for lower privilege modes.

S/HS-mode software should:

1. Call to M-mode to apply the debug policy before launching an application or VM.  
2. Provide interfaces to handle dynamic debug policy update requests (e.g., SBI calls from VMs) and call to M-mode to apply the debug policy accordingly.
3. Context-switch debug policies when switching between applications or VMs

=== VS-mode Management

VS-mode software is responsible for managing debug policy for applications in VU-mode.
VS-mode software should:

1. Call to S/HS-mode to apply the debug policy before launching an application.  
2. Context-switch debug policies when switching between applications

[appendix]
== Execution Based Implementation with Sdsec

In an execution-based implementation, the code executing the "park loop" can always run with M-mode privilege to access the memory and CSR. However, once execution is dispatched to an Abstract Command or the program buffer, the privilege level for accessing memory and CSR should be restricted to <<dbgaccpriv, debug access privilege>>. 

To achieve this, a Debug Mode only state element (e.g., a field in a custom CSR) may be introduced to control the privilege level in Debug Mode. When the state is set to 1, Debug Mode allows M-mode privilege; when cleared to 0, it enforces the <<dbgaccpriv, debug access privilege>>. The hardware sets this state to 1 upon entering the park loop and clears it to 0 by the final instruction of the park loop, right before execution is transferred to an Abstract Command or the program buffer.